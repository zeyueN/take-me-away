<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Photo Gallery</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
        .gallery-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .collection {
            margin-bottom: 40px;
            position: relative;
            min-height: 600px;
        }
        
        .collection canvas {
            width: 100%;
            height: auto;
            cursor: pointer;
            max-height: none;
        }
        
        .description {
            margin-top: 10px;
            font-family: sans-serif;
        }
        
        @media (max-width: 768px) {
            .gallery-container {
                padding: 10px;
            }
        }

        /* Loading indicator */
        .loading-bar {
            height: 2px;
            background: #777;
            transition: width 0.3s ease;
        }
    </style>
</head>
<body>
    <div class="gallery-container">
        <div class="graphic">
            <!-- Album template -->
            <div class="collection" data-slug="album-1" data-size="12">
                <div class="description">Sample Album</div>
            </div>
        </div>
    </div>

<script>
(function() {
    const DISTORTION_FACTOR = 6;  // Adjust this value to control distortion amount

    let width;
    let height = 600;

    const graphic = d3.select(".graphic");
    
    // First create canvas elements
    let canvas = graphic.selectAll(".collection")
        .datum(function() {
            return {
                slug: this.getAttribute("data-slug"),
                size: parseInt(this.getAttribute("data-size"))
            };
        })
        .append("canvas");

    // Now we can get the context
    const pixelRatio = window.devicePixelRatio || 1;
    const storeRatio = (function() {
        const context = canvas.node().getContext("2d");
        const backingStoreRatio = context.webkitBackingStorePixelRatio ||
            context.mozBackingStorePixelRatio ||
            context.msBackingStorePixelRatio ||
            context.oBackingStorePixelRatio ||
            context.backingStorePixelRatio || 1;
        return pixelRatio / backingStoreRatio;
    })();

    canvas
        .attr("height", height * storeRatio)
        .style("height", height + "px");

    // Add loading indicator
    const loadingBar = canvas.append("div")
        .attr("class", "loading-bar")
        .style("width", "0%");

    // Setup annotations
    const annotations = canvas.select(".annotations");
    annotations.selectAll("li")
        .datum(function() {
            return {
                range: JSON.parse(this.getAttribute("data-range"))
            };
        });

    // Event listeners
    d3.select(window)
        .on("scroll", scroll)
        .on("resize", resize);

    resize();

    function resize() {
        width = parseInt(graphic.style("width"));
        console.log(`Resize called. New width: ${width}`);
        
        annotations.style("width", width + "px");

        canvas
            .attr("width", width)
            .attr("height", height)
            .style("width", width + "px")
            .style("height", height + "px")
            .each(function(d) {
                d.context = this.getContext("2d");
                d.context.strokeStyle = "rgba(0,0,0,0.8)";
                if (d.enabled) d.resize();
            });

        scroll();
    }

    function scroll() {
        const dy = window.innerHeight;
        if (!canvas
            .filter(function() {
                const box = this.getBoundingClientRect();
                return box.bottom > 0 && box.top < dy;
            })
            .each(enableFisheye)
            .empty()) {
            canvas = canvas.filter(d => !d.enabled);
        }
    }

// Replace the image loading section with this debug-friendly version
function enableFisheye(d) {
    d.enabled = true;

    const that = this;
    const normalWidth = width / d.size;
    const imageWidth = Math.ceil(normalWidth * pixelRatio);
    const imageHeight = height;
    let desiredDistortion = 0;
    let desiredFocus = width / 2;
    let progress = 0;
    let idle = true;

    const x = fisheye()
        .distortion(0)
        .extent([0, width])
        .focus(width / 2);

    const annotation = annotations.selectAll("li");

    // Load and cache images with loading progress and error handling
    const images = new Array(d.size).fill(null);
    let loadedImages = 0;
    const totalImages = d.size;

    function constructImagePath(index) {
        const baseUrl = window.location.hostname.includes('github.io') 
            ? `/take-me-away` 
            : '';
        const path = `${baseUrl}/albums/${d.slug}/photo${index + 1}.jpg`;
        return path;
    }

    for (let i = 0; i < totalImages; i++) {
        const img = new Image();
        const imagePath = constructImagePath(i);
        const index = i;
        
        img.onload = () => {
            // Create a canvas to process the image
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            // For portrait images, crop to center square
            if (img.height > img.width) {
                const size = img.width;  // Use width as the square size
                const startY = (img.height - size) / 2;  // Center vertically
                
                canvas.width = size;
                canvas.height = size;
                
                // Draw only the center square portion
                ctx.drawImage(img, 
                    0, startY, size, size,  // Source rectangle
                    0, 0, size, size        // Destination rectangle
                );
                
                // Create new image from canvas
                const squareImg = new Image();
                squareImg.onload = () => {
                    images[index] = squareImg;
                    loadedImages++;
                    progress = (loadedImages / totalImages) * 100;
                    loadingBar.style("width", progress + "%");
                    
                    if (loadedImages === totalImages) {
                        loadingBar.remove();
                        initialize();
                    }
                    render();
                };
                squareImg.src = canvas.toDataURL();
            } else {
                // For landscape or square images, use as is
                images[index] = img;
                loadedImages++;
                progress = (loadedImages / totalImages) * 100;
                loadingBar.style("width", progress + "%");
                
                if (loadedImages === totalImages) {
                    loadingBar.remove();
                    initialize();
                }
                render();
            }
        };

        img.onerror = (e) => {
            console.error(`Failed to load image ${index + 1}: ${imagePath}`);
            console.error('Error details:', e);
            loadedImages++;
        };

        img.src = imagePath;
    }

    function initialize() {
        d3.select(that)
            .on("mousedown", mousedown)
            .on("mouseover", mouseover)
            .on("mousemove", mousemove)
            .on("mouseout", mouseout)
            .on("touchstart", touchstart)
            .on("touchmove", mousemove)
            .on("touchend", mouseout);

        render();
    }

    function render() {
        if (this.renderTimeout) return;
        
        this.renderTimeout = setTimeout(() => {
            this.renderTimeout = null;
            
            if (!d.context) {
                console.error('No context available');
                return;
            }

            const context = d.context;
            context.clearRect(0, 0, width * storeRatio, height * storeRatio);

            for (let i = 0; i < d.size; i++) {
                const x0 = x(i * normalWidth);
                const x1 = x((i + 1) * normalWidth);
                const slotWidth = x1 - x0;
                
                try {
                    const img = images[i];
                    if (!img || !img.complete) continue;

                    // Calculate scaling to fill height while maintaining aspect ratio
                    const scale = height / img.height;
                    const scaledWidth = img.width * scale;
                    
                    // Calculate how much of the image width to use
                    const sourceWidth = slotWidth / scale;
                    const sourceX = (img.width - sourceWidth) / 2;

                    context.drawImage(
                        img,
                        sourceX, 0, sourceWidth, img.height,  // Source rectangle
                        x0, 0, slotWidth, height              // Destination rectangle
                    );
                    
                    context.beginPath();
                    context.moveTo(x0, 0);
                    context.lineTo(x0, height);
                    context.stroke();
                } catch (e) {
                    console.error(`Error rendering image ${i}:`, e);
                }
            }

            context.strokeRect(0, 0, width, height);
        }, 16);
    }

    function move() {
        if (idle) {
            idle = false;
            
            if (this.moveTimer) {
                this.moveTimer.stop();
            }
            
            const startDistortion = x.distortion();
            const startFocus = x.focus();
            
            // Changed duration to 200ms
            const duration = 200;
            
            this.moveTimer = d3.timer((elapsed) => {
                const t = Math.min(1, elapsed / duration);
                const progress = t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
                
                x.distortion(startDistortion + (desiredDistortion - startDistortion) * progress);
                x.focus(startFocus + (desiredFocus - startFocus) * progress);
                render();
                
                if (t >= 1) {
                    idle = true;
                    return true;
                }
            });
        }
    }

    function mouseover(event) {
        desiredDistortion = (imageWidth / normalWidth - 1) * DISTORTION_FACTOR;
        if (event) {
            mousemove(event);
        }
    }

    function mouseout(event) {
        desiredDistortion = 0;
        if (event) {
            mousemove(event);
        }
    }

    function mousemove(event) {
        if (!event) return;
        
        const [mouseX] = d3.pointer(event, that);
        desiredFocus = Math.max(0, Math.min(width - 1e-6, mouseX));
        move();
    }

    function mousedown(event) {
        if (!event) return;
        const m = Math.max(0, Math.min(width - 1e-6, d3.pointer(event, that)[0]));
        let i;
        for (i = 0; i < d.size && x(i * normalWidth) < m; i++);
        link.href = `#photo-${i + 1}`;
        link.click();  // Trigger the click on the temporary link
    }

    function touchstart(event) {
        event.preventDefault();
        mouseover(event);
        if (event.touches.length === 1) {
            const now = Date.now();
            if (now - touchtime < 500) mousedown(event), link.click();
            touchtime = now;
        }
    }

    d.resize = function() {
        const f = x.focus() / x.extent()[1];
        const d1 = imageWidth / normalWidth - 1;
        const d0 = x.distortion() / d1;
        normalWidth = width / d.size;
        x.distortion(d0 * d1).extent([0, width]).focus(f * width);
        render();
    };
}

function fisheye() {
    let min = 0,
        max = 1,
        distortion = 3,
        focus = 0;

    function G(x) {
        const d = distortion * (DISTORTION_FACTOR/3);  // Reduced factor division to maintain squeeze
        return (d + 1) * x / ((d * x) + 1);
    }

    function fisheye(x) {
        const Dmax_x = (x < focus ? min : max) - focus;
        const Dnorm_x = x - focus;
        return G(Dnorm_x / Dmax_x) * Dmax_x + focus;
    }

    fisheye.extent = function(_) {
        if (!arguments.length) return [min, max];
        min = +_[0], max = +_[1];
        return fisheye;
    };

    fisheye.distortion = function(_) {
        if (!arguments.length) return distortion;
        distortion = +_;
        return fisheye;
    };

    fisheye.focus = function(_) {
        if (!arguments.length) return focus;
        focus = +_;
        return fisheye;
    };

    return fisheye;
}
})();
</script>
</body>
</html>
